package uk.gov.hmcts.contino

import groovy.json.JsonOutput
import groovy.json.JsonSlurperClassic

class FortifyVulnerabilityReporter implements Serializable {

  private static final String DEFAULT_RELEASE_PROPERTIES_PATH = 'config/fortify-client.properties'
  private static final String DEFAULT_API_BASE_URL = 'https://api.emea.fortify.com'
  private static final String DEFAULT_PORTAL_BASE_URL = 'https://emea.fortify.com'

  private static final int DEFAULT_PAGE_LIMIT = 200
  private static final int DEFAULT_MAX_VULNERABILITIES = 500
  private static final int DEFAULT_MAX_CONSOLE_FINDINGS = 20
  private static final int DEFAULT_SCAN_POLL_ATTEMPTS = 6
  private static final int DEFAULT_SCAN_POLL_SLEEP_SECONDS = 10
  private static final int FOD_VULNERABILITIES_MAX_LIMIT = 50

  private final def steps

  FortifyVulnerabilityReporter(steps) {
    this.steps = steps
  }

  void generate(Map options = [:]) {
    Integer releaseId = resolveReleaseId(options)
    if (!releaseId) {
      steps.echo("Fortify: unable to determine releaseId (expected ${DEFAULT_RELEASE_PROPERTIES_PATH}); skipping vulnerability details")
      return
    }

    String apiBaseUrl = (options.apiBaseUrl ?: steps.env.FORTIFY_API_BASE_URL ?: DEFAULT_API_BASE_URL).toString().trim()
    String portalBaseUrl = (options.portalBaseUrl ?: steps.env.FORTIFY_PORTAL_BASE_URL ?: DEFAULT_PORTAL_BASE_URL).toString().trim()

    String username = (steps.env.FORTIFY_USER_NAME ?: '').toString().trim()
    String password = (steps.env.FORTIFY_PASSWORD ?: '').toString().trim()
    if (!username || !password) {
      steps.echo('Fortify: missing FORTIFY_USER_NAME/FORTIFY_PASSWORD; skipping vulnerability details')
      return
    }

    try {
      steps.sh("mkdir -p 'Fortify Scan'")
      String scope = (options.scope ?: steps.env.FORTIFY_OAUTH_SCOPE ?: 'api-tenant').toString().trim()
      String configuredGrantType = (options.grantType ?: steps.env.FORTIFY_VULN_AUTH_MODE ?: steps.env.FORTIFY_OAUTH_GRANT_TYPE ?: 'auto').toString().trim()
      String normalizedGrantType = (configuredGrantType ?: 'auto').toString().trim().toLowerCase()
      String patToken = (options.patToken ?: steps.env.FORTIFY_PAT ?: steps.env.FORTIFY_PAT_TOKEN ?: '').toString().trim()

      List<Map> authOptions = resolveAuthOptions(apiBaseUrl, username, password, scope, configuredGrantType, patToken)
      String effectiveMode = (authOptions?.first()?.mode ?: normalizedGrantType ?: 'unknown').toString()
      steps.echo("Fortify: vulnerability fetch auth mode: ${effectiveMode} (configured: ${configuredGrantType ?: 'auto'})")
      int pollAttempts = options.containsKey('scanPollAttempts') ? (options.scanPollAttempts as int) : DEFAULT_SCAN_POLL_ATTEMPTS
      int pollSleepSeconds = options.containsKey('scanPollSleepSeconds') ? (options.scanPollSleepSeconds as int) : DEFAULT_SCAN_POLL_SLEEP_SECONDS
      int pageLimit = (options.pageLimit ?: DEFAULT_PAGE_LIMIT) as int
      int maxVulnerabilities = (options.maxVulnerabilities ?: DEFAULT_MAX_VULNERABILITIES) as int
      def fetch = { List<Map> opts ->
        Map scan = fetchLatestCompletedStaticScanWithRetry(apiBaseUrl, opts, releaseId, pollAttempts, pollSleepSeconds)
        Integer id = scan?.scanId != null ? (scan.scanId as Integer) : null
        if (!id) {
          steps.echo("Fortify: scanId not available from /scans for releaseId=${releaseId}; fetching vulnerabilities without scan filter")
        }
        List<Map> vulns = fetchVulnerabilities(apiBaseUrl, opts, releaseId, id, pageLimit, maxVulnerabilities)
        return [scan: scan, scanId: id, vulnerabilities: vulns]
      }

      Map result
      try {
        result = fetch(authOptions) as Map
      } catch (FoDRequestException e) {
        // Some Jenkins environments set FORTIFY_OAUTH_GRANT_TYPE=pat globally; if the "PAT" is actually a client secret,
        // FoD will 401. Retry once using the normal OAuth auto-mode before giving up.
        if (isUnauthorized(e) && normalizedGrantType == 'pat') {
          steps.echo('Fortify: PAT auth rejected; retrying vulnerability fetch using OAuth auto mode')
          authOptions = resolveAuthOptions(apiBaseUrl, username, password, scope, 'auto', patToken)
          result = fetch(authOptions) as Map
        } else {
          throw e
        }
      }

      Map latestScan = (result.scan ?: [:]) as Map
      Integer scanId = result.scanId != null ? (result.scanId as Integer) : null
      List<Map> vulnerabilities = (result.vulnerabilities ?: []) as List<Map>

      writeReports(
        portalBaseUrl: portalBaseUrl,
        apiBaseUrl: apiBaseUrl,
        releaseId: releaseId,
        scan: latestScan,
        vulnerabilities: vulnerabilities,
        truncated: vulnerabilities.size() >= maxVulnerabilities
      )

      echoSummary(portalBaseUrl, releaseId, scanId, vulnerabilities, (options.maxConsoleFindings ?: DEFAULT_MAX_CONSOLE_FINDINGS) as int)
    } catch (Exception e) {
      steps.echo("Fortify: failed to fetch vulnerability details: ${e.message}")
    }
  }

  private Integer resolveReleaseId(Map options) {
    if (options.releaseId != null) {
      return (options.releaseId as String).trim().isInteger() ? (options.releaseId as Integer) : null
    }

    String envReleaseId = (steps.env.FORTIFY_RELEASE_ID ?: '').toString().trim()
    if (envReleaseId.isInteger()) {
      return Integer.parseInt(envReleaseId)
    }

    // When scans are started via the library runner, Fortify Scan/FortifyScanReport.html includes releaseId=...
    String scanReportPath = (options.scanReportPath ?: 'Fortify Scan/FortifyScanReport.html').toString()
    if (steps.fileExists(scanReportPath)) {
      try {
        String reportText = steps.readFile(scanReportPath) ?: ''
        def reportMatcher = (reportText =~ /(?m)^\s*releaseId\s*[:=]\s*(\d+)\s*$/)
        if (reportMatcher.find()) {
          return Integer.parseInt(reportMatcher.group(1))
        }
      } catch (ignored) {
        // best-effort only
      }
    }

    String propertiesPath = (options.releasePropertiesPath ?: DEFAULT_RELEASE_PROPERTIES_PATH).toString()
    if (!steps.fileExists(propertiesPath)) {
      return null
    }

    String text = steps.readFile(propertiesPath) ?: ''
    def matcher = (text =~ /(?m)^\s*fortify\.client\.releaseId\s*=\s*(\d+)\s*$/)
    if (!matcher.find()) {
      return null
    }

    return Integer.parseInt(matcher.group(1))
  }

  private List<Map> resolveAuthOptions(String apiBaseUrl, String username, String password, String scope, String grantType, String patToken) {
    String normalized = (grantType ?: 'auto').toString().trim().toLowerCase()

    Map basic = basicAuthOption(username, password)

    // Back-compat: some setups historically stored PAT in FORTIFY_PASSWORD when username is an email.
    boolean legacyPatFromPassword = username.contains('@')
    String effectivePatToken = (patToken ?: (legacyPatFromPassword ? password : '')).toString().trim()
    Map pat = effectivePatToken ? bearerAuthOption('pat', effectivePatToken) : null

    // If PAT mode is configured but we don't actually have a token, treat it as a misconfiguration and use auto.
    if (normalized == 'pat' && !effectivePatToken) {
      steps.echo('Fortify: PAT mode configured but no PAT token found; using OAuth auto mode')
      normalized = 'auto'
    }

    if (normalized == 'basic') {
      return pat ? [basic, pat] : [basic]
    }
    if (normalized == 'pat') {
      return [pat, basic]
    }
    if (normalized == 'password' || normalized == 'client_credentials') {
      String token = fetchAccessTokenForGrant(apiBaseUrl, username, password, scope, normalized)
      List<Map> opts = [bearerAuthOption("oauth:${normalized}", token), basic]
      if (pat) {
        opts.add(pat)
      }
      return opts
    }

    String first = (username.contains('\\') || username.contains('@')) ? 'password' : 'client_credentials'
    String second = first == 'password' ? 'client_credentials' : 'password'

    try {
      String token = fetchAccessTokenForGrant(apiBaseUrl, username, password, scope, first)
      List<Map> opts = [bearerAuthOption("oauth:${first}", token), basic]
      if (pat) {
        opts.add(pat)
      }
      return opts
    } catch (Exception e) {
      steps.echo("Fortify: token request failed using ${first}; retrying with ${second}")
      try {
        String token = fetchAccessTokenForGrant(apiBaseUrl, username, password, scope, second)
        List<Map> opts = [bearerAuthOption("oauth:${second}", token), basic]
        if (pat) {
          opts.add(pat)
        }
        return opts
      } catch (Exception e2) {
        // Heuristic: tenant\\user credentials are commonly used with Basic auth; email-style users more commonly use PAT fallback.
        boolean preferBasic = username.contains('\\')
        String fallbackMode = preferBasic || !pat ? 'basic' : 'pat'
        steps.echo("Fortify: token request failed for OAuth grants; falling back to ${fallbackMode} auth")
        return fallbackMode == 'pat' ? [pat, basic] : (pat ? [basic, pat] : [basic])
      }
    }
  }

  private String fetchAccessTokenForGrant(String apiBaseUrl, String username, String password, String scope, String grantType) {
    String normalized = grantType.toLowerCase()
    if (normalized != 'password' && normalized != 'client_credentials') {
      throw new IllegalArgumentException("Unsupported grantType: ${grantType}")
    }

    String requestData = (normalized == 'client_credentials')
      ? """--data-urlencode 'grant_type=client_credentials' \\
          --data-urlencode 'scope=${scope}' \\
          --data-urlencode "client_id=${username}" \\
          --data-urlencode "client_secret=${password}"
        """.stripIndent()
      : """--data-urlencode 'grant_type=password' \\
          --data-urlencode 'scope=${scope}' \\
          --data-urlencode "username=${username}" \\
          --data-urlencode "password=${password}"
        """.stripIndent()

    String responseText = steps.sh(
      script: """#!/bin/bash -e
        set +x
        curl -sS -X POST '${apiBaseUrl}/oauth/token' \\
          -H 'Content-Type: application/x-www-form-urlencoded' \\
          ${requestData}
      """.stripIndent(),
      returnStdout: true
    )?.trim()

    def json = new JsonSlurperClassic().parseText(responseText ?: '{}') as Map
    String token = json.access_token as String
    if (!token) {
      String details = (json.error_description ?: json.error ?: responseText ?: 'Unknown error').toString()
      throw new RuntimeException("token request failed: ${details}")
    }
    return token
  }

  private Map fetchLatestCompletedStaticScanWithRetry(String apiBaseUrl, List<Map> authOptions, Integer releaseId, int attempts, int sleepSeconds) {
    int tries = Math.max(attempts, 1)
    int delay = Math.max(sleepSeconds, 0)

    for (int i = 1; i <= tries; i++) {
      boolean allowFallback = (i == tries)
      Map scan = fetchLatestCompletedStaticScan(apiBaseUrl, authOptions, releaseId, allowFallback)
      if (scan?.scanId) {
        return scan
      }
      if (i < tries && delay > 0) {
        steps.echo("Fortify: scan not completed yet; retrying (${i}/${tries})...")
        steps.sleep(time: delay, unit: 'SECONDS')
      }
    }

    return [:]
  }

  private Map fetchLatestCompletedStaticScan(String apiBaseUrl, List<Map> authOptions, Integer releaseId, boolean allowFallbackToAnyCompleted = false) {
    String url = "${apiBaseUrl}/api/v3/releases/${releaseId}/scans"
    String scriptTemplate = '''#!/bin/bash -e
      set +x
      body_file=`mktemp`
      header_file=`mktemp`
      curl -sS -G '__URL__' \
        -H 'Accept: application/json' \
        -H '__AUTH_HEADER__' \
        --data-urlencode 'orderBy=startedDateTime' \
        --data-urlencode 'orderByDirection=DESC' \
        --data-urlencode 'limit=20' \
        --data-urlencode 'fields=scanId,scanType,analysisStatusType,startedDateTime,completedDateTime,issueCountCritical,issueCountHigh,issueCountMedium,issueCountLow,totalIssues' \
        -o "$body_file" \
        -D "$header_file"

      code=`awk 'NR==1{print $2}' "$header_file" 2>/dev/null || true`
      if [ -z "$code" ]; then
        code="unknown"
      fi
      cat "$body_file"
      echo
      echo "$code"
      rm -f "$body_file" "$header_file"
    '''.stripIndent()

    String responseText = requestBodyWithAuthFallback(scriptTemplate, url, authOptions)

    def parsed = new JsonSlurperClassic().parseText(responseText ?: '{}')
    List<Map> items
    if (parsed instanceof List) {
      items = parsed as List<Map>
    } else {
      Map json = parsed as Map
      items = (json.items ?: json.data ?: []) as List<Map>
    }

    if (items.isEmpty()) {
      return [:]
    }

    // The API is ordered by startedDateTime DESC; prefer the most recent static scan if it's completed.
    List<Map> staticScans = items.findAll { Map s -> normalizeField(s.scanType).toLowerCase().contains('static') } as List<Map>
    if (!staticScans.isEmpty()) {
      Map mostRecentStatic = staticScans.first()
      String status = normalizeField(mostRecentStatic.analysisStatusType)
      if (status.equalsIgnoreCase('Completed')) {
        return mostRecentStatic
      }
      if (allowFallbackToAnyCompleted) {
        Map lastCompletedStatic = staticScans.find { Map s -> normalizeField(s.analysisStatusType).equalsIgnoreCase('Completed') }
        if (lastCompletedStatic?.scanId) {
          steps.echo("Fortify: latest static scanId=${mostRecentStatic.scanId} is ${status}; using last completed static scanId=${lastCompletedStatic.scanId} for vulnerability details")
          return lastCompletedStatic
        }
      }
      return [:]
    }

    Map completed = items.find { Map s -> normalizeField(s.analysisStatusType).equalsIgnoreCase('Completed') }
    return completed ?: [:]
  }

  private static String normalizeField(Object value) {
    if (value == null) {
      return ''
    }
    if (value instanceof Map) {
      def m = value as Map
      Object candidate = m.name ?: m.value ?: m.type ?: m.displayName ?: m.text ?: m.code
      return (candidate == null ? m.toString() : candidate.toString()).trim()
    }
    return value.toString().trim()
  }

  private List<Map> fetchVulnerabilities(String apiBaseUrl, List<Map> authOptions, Integer releaseId, Integer scanId, int pageLimit, int maxVulnerabilities) {
    List<Map> all = []
    int offset = 0
    String url = "${apiBaseUrl}/api/v3/releases/${releaseId}/vulnerabilities"

    while (all.size() < maxVulnerabilities) {
      int remaining = maxVulnerabilities - all.size()
      int limit = Math.min(Math.min(pageLimit, remaining), FOD_VULNERABILITIES_MAX_LIMIT)

      String scanFilterLine = scanId != null ? "        --data-urlencode 'filters=scanId:${scanId}' \\\n" : ''
      String scriptTemplate = '''#!/bin/bash -e
        set +x
        body_file=`mktemp`
        header_file=`mktemp`
        curl -sS -G '__URL__' \
          -H 'Accept: application/json' \
          -H '__AUTH_HEADER__' \
__SCAN_FILTER__          --data-urlencode 'orderBy=severity' \
          --data-urlencode 'orderByDirection=DESC' \
          --data-urlencode 'includeFixed=false' \
          --data-urlencode 'includeSuppressed=false' \
          --data-urlencode 'offset=__OFFSET__' \
          --data-urlencode 'limit=__LIMIT__' \
          --data-urlencode 'fields=id,vulnId,severityString,category,kingdom,cwe,primaryLocationFull,lineNumber,analysisType,developerStatus,auditorStatus,status,scanId' \
          -o "$body_file" \
          -D "$header_file"

        code=`awk 'NR==1{print $2}' "$header_file" 2>/dev/null || true`
        if [ -z "$code" ]; then
          code="unknown"
        fi
        cat "$body_file"
        echo
        echo "$code"
        rm -f "$body_file" "$header_file"
      '''.stripIndent()

      scriptTemplate = scriptTemplate
        .replace('__SCAN_FILTER__', scanFilterLine)
        .replace('__OFFSET__', offset.toString())
        .replace('__LIMIT__', limit.toString())

      String responseText = requestBodyWithAuthFallback(scriptTemplate, url, authOptions)

      def parsed = new JsonSlurperClassic().parseText(responseText ?: '{}')
      List<Map> items
      if (parsed instanceof List) {
        items = parsed as List<Map>
      } else {
        Map json = parsed as Map
        items = (json.items ?: json.data ?: []) as List<Map>
      }
      all.addAll(items)

      if (items.size() < limit) {
        break
      }
      offset += limit
    }

    return all
  }

  private String requestBodyWithAuthFallback(String scriptTemplate, String url, List<Map> authOptions) {
    if (authOptions == null || authOptions.isEmpty()) {
      throw new IllegalArgumentException('No auth options provided')
    }

    Exception last
    for (int i = 0; i < authOptions.size(); i++) {
      Map auth = authOptions[i] as Map
      String script = scriptTemplate
        .replace('__URL__', url)
        .replace('__AUTH_HEADER__', (auth.header ?: '').toString())

      try {
        String combined = steps.sh(script: script, returnStdout: true)?.toString()
        return bodyFromCombinedResponseOrThrow(combined)
      } catch (FoDRequestException e) {
        last = e
        if (!isUnauthorized(e) || i == authOptions.size() - 1) {
          throw e
        }
        String nextMode = (authOptions[i + 1]?.mode ?: 'unknown').toString()
        steps.echo("Fortify: auth failed using ${(auth.mode ?: 'unknown')}; retrying with ${nextMode}")
      }
    }

    throw last ?: new RuntimeException('FoD API request failed')
  }

  private static boolean isUnauthorized(FoDRequestException e) {
    if (e == null) {
      return false
    }
    if (e.statusCode != null) {
      return e.statusCode == 401 || e.statusCode == 403
    }
    String message = (e.message ?: '').toLowerCase()
    return message.contains('401') || message.contains('403') || message.contains('authorization failure') || message.contains('unauthorized')
  }

  private static Map bearerAuthOption(String mode, String token) {
    return [mode: mode, header: "Authorization: Bearer ${token}".toString()]
  }

  private static Map basicAuthOption(String username, String password) {
    String raw = "${username}:${password}".toString()
    String b64 = raw.bytes.encodeBase64().toString()
    return [mode: 'basic', header: "Authorization: Basic ${b64}".toString()]
  }

  private String bodyFromCombinedResponseOrThrow(String combined) {
    if (combined == null) {
      throw new FoDRequestException(null, 'unknown', 'FoD API request failed: empty response')
    }

    // Jenkins' sh step typically returns a trailing newline; treat the *last non-empty line* as the HTTP status code.
    String trimmedCombined = combined.toString().replaceFirst(/\s+$/, '')
    int idx = trimmedCombined.lastIndexOf('\n')
    if (idx < 0) {
      throw new FoDRequestException(null, 'unknown', 'FoD API request failed: missing status code line')
    }

    String body = trimmedCombined.substring(0, idx).trim()
    String code = trimmedCombined.substring(idx + 1).trim()

    if (!(code ==~ /2\d\d/)) {
      String bodySnippet = body ?: 'empty body'
      if (bodySnippet.length() > 1500) {
        bodySnippet = bodySnippet.substring(0, 1500) + '...'
      }
      Integer status = parseStatusCode(code, body)
      String display = (status != null ? status.toString() : (code ?: 'unknown'))
      throw new FoDRequestException(status, display, "FoD API request failed (HTTP ${display}): ${bodySnippet}")
    }

    return body
  }

  private static Integer parseStatusCode(String code, String body) {
    if (code != null && code ==~ /\d{3}/) {
      return Integer.parseInt(code)
    }
    if (!body) {
      return null
    }
    try {
      def parsed = new JsonSlurperClassic().parseText(body ?: '{}')
      if (!(parsed instanceof Map)) {
        return null
      }
      Map json = parsed as Map
      def rc = json.responseCode
      if (rc == null) {
        return null
      }
      String rcString = rc.toString().trim()
      return rcString.isInteger() ? Integer.parseInt(rcString) : null
    } catch (ignored) {
      return null
    }
  }

  private static class FoDRequestException extends RuntimeException {
    final Integer statusCode
    final String statusDisplay

    FoDRequestException(Integer statusCode, String statusDisplay, String message) {
      super(message)
      this.statusCode = statusCode
      this.statusDisplay = statusDisplay
    }
  }

  private void writeReports(Map report) {
    String jsonPath = 'Fortify Scan/FortifyVulnerabilities.json'
    String htmlPath = 'Fortify Scan/FortifyVulnerabilities.html'

    String portalIssuesUrl = "${report.portalBaseUrl}/Releases/${report.releaseId}/Issues"
    Map payload = [
      generatedAt     : new Date().format("yyyy-MM-dd'T'HH:mm:ssXXX"),
      apiBaseUrl      : report.apiBaseUrl,
      portalIssuesUrl : portalIssuesUrl,
      releaseId       : report.releaseId,
      scan            : report.scan,
      truncated       : report.truncated,
      vulnerabilities : report.vulnerabilities
    ]

    steps.writeFile(file: jsonPath, text: JsonOutput.prettyPrint(JsonOutput.toJson(payload)))
    steps.writeFile(file: htmlPath, text: renderHtmlReport(payload))
    steps.archiveArtifacts allowEmptyArchive: true, artifacts: 'Fortify Scan/FortifyVulnerabilities.*'
  }

  private void echoSummary(String portalBaseUrl, Integer releaseId, Integer scanId, List<Map> vulnerabilities, int maxConsoleFindings) {
    String portalIssuesUrl = "${portalBaseUrl}/Releases/${releaseId}/Issues"
    Map bySeverity = vulnerabilities.groupBy { (it.severityString ?: 'Unknown').toString() } as Map
    String counts = bySeverity
      .collect { k, v -> "${k}:${v.size()}" }
      .sort()
      .join(', ')

    steps.echo("Fortify: vulnerability details for releaseId=${releaseId}, scanId=${scanId ?: 'Unknown'} (${counts}). Portal: ${portalIssuesUrl}")

    List<Map> notable = vulnerabilities.findAll { (it.severityString ?: '').toString().equalsIgnoreCase('Critical') || (it.severityString ?: '').toString().equalsIgnoreCase('High') }
    if (notable.isEmpty()) {
      return
    }

    int shown = 0
    notable.each { Map v ->
      if (shown >= maxConsoleFindings) {
        return
      }
      String sev = (v.severityString ?: 'Unknown').toString()
      String id = (v.id ?: v.vulnId ?: '').toString()
      String category = (v.category ?: '').toString()
      String location = (v.primaryLocationFull ?: '').toString()
      String line = (v.lineNumber ?: '').toString()
      steps.echo("Fortify: ${sev} ${id} ${category} @ ${location}${line ? ':' + line : ''}".trim())
      shown++
    }

    if (notable.size() > shown) {
      steps.echo("Fortify: ${notable.size() - shown} more High/Critical findings in Fortify Scan/FortifyVulnerabilities.html")
    }
  }

  private String renderHtmlReport(Map payload) {
    Integer releaseId = payload.releaseId as Integer
    Integer scanId = (payload.scan?.scanId ?: null) as Integer
    String portalIssuesUrl = payload.portalIssuesUrl.toString()
    boolean truncated = (payload.truncated ?: false) as boolean
    List<Map> vulnerabilities = (payload.vulnerabilities ?: []) as List<Map>

    Map<String, Integer> countsBySeverity = (vulnerabilities.groupBy { (it.severityString ?: 'Unknown').toString() } as Map<String, List>)
      .collectEntries { k, v -> [(k): v.size()] } as Map<String, Integer>

    StringBuilder rows = new StringBuilder()
    vulnerabilities.each { Map v ->
      rows.append('<tr>')
      rows.append("<td>${escapeHtml(v.severityString)}</td>")
      rows.append("<td>${escapeHtml(v.category)}</td>")
      rows.append("<td>${escapeHtml(v.kingdom)}</td>")
      rows.append("<td>${escapeHtml(v.cwe)}</td>")
      rows.append("<td>${escapeHtml(v.primaryLocationFull)}</td>")
      rows.append("<td>${escapeHtml(v.lineNumber)}</td>")
      rows.append("<td>${escapeHtml(v.vulnId)}</td>")
      rows.append("<td>${escapeHtml(v.id)}</td>")
      rows.append('</tr>\n')
    }

    String severitySummary = countsBySeverity
      .collect { k, v -> "${k}: ${v}" }
      .sort()
      .join(' | ')

    return """<!doctype html>
      <html>
        <head>
          <meta charset="utf-8" />
          <title>Fortify Vulnerabilities</title>
          <style>
            body { font-family: Arial, sans-serif; margin: 16px; }
            table { border-collapse: collapse; width: 100%; }
            th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
            th { background: #f5f5f5; text-align: left; }
            code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; }
            .meta { margin: 0 0 12px 0; }
            .warn { color: #8a6d3b; }
          </style>
        </head>
        <body>
          <h2>Fortify On Demand Vulnerabilities</h2>
          <p class="meta"><strong>Release:</strong> ${releaseId} &nbsp; <strong>Scan:</strong> ${scanId ?: 'Unknown'} &nbsp; <a href="${escapeHtml(portalIssuesUrl)}">Open in Fortify Portal</a></p>
          <p class="meta"><strong>Summary:</strong> ${escapeHtml(severitySummary ?: 'No vulnerabilities returned')}</p>
          ${truncated ? '<p class="warn"><strong>Note:</strong> Output truncated; see the Fortify portal for the full list.</p>' : ''}
          <table>
            <thead>
              <tr>
                <th>Severity</th>
                <th>Category</th>
                <th>Kingdom</th>
                <th>CWE</th>
                <th>Location</th>
                <th>Line</th>
                <th>Vuln ID</th>
                <th>Issue ID</th>
              </tr>
            </thead>
            <tbody>
              ${rows.toString()}
            </tbody>
          </table>
        </body>
      </html>
    """.stripIndent()
  }

  private static String escapeHtml(Object o) {
    String s = (o == null) ? '' : o.toString()
    return s
      .replace('&', '&amp;')
      .replace('<', '&lt;')
      .replace('>', '&gt;')
      .replace('\"', '&quot;')
      .replace("'", '&#39;')
  }
}
