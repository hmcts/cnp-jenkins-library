package uk.gov.hmcts.contino

import spock.lang.Specification

class FortifyVulnerabilityReporterTest extends Specification {

  def steps
  FortifyVulnerabilityReporter reporter

  def setup() {
    steps = Mock(JenkinsStepMock)
    reporter = new FortifyVulnerabilityReporter(steps)
  }

  def "skips when releaseId cannot be determined"() {
    given:
      steps.env >> [:]
      steps.fileExists('config/fortify-client.properties') >> false

    when:
      reporter.generate()

    then:
      1 * steps.echo({ it.contains('unable to determine releaseId') })
      0 * steps.sh(_)
      0 * steps.writeFile(_)
  }

  def "writes vulnerability reports when api calls succeed"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'tenant\\\\user', FORTIFY_PASSWORD: 'pass']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      def scansResponse = '{"items":[{"scanId":2274756,"scanType":{"name":"Static"},"analysisStatusType":{"name":"Completed"},"issueCountHigh":2,"issueCountCritical":0,"issueCountMedium":0,"issueCountLow":0}]}'
      def vulnsResponse = '{"items":[{"id":1,"vulnId":"v1","severityString":"High","category":"XSS","primaryLocationFull":"src/app.js","lineNumber":10},{"id":2,"vulnId":"v2","severityString":"High","category":"SQL Injection","primaryLocationFull":"src/db.js","lineNumber":20}]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("/oauth/token") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "${scansResponse}\n200"
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") && m.returnStdout == true }) >> "${vulnsResponse}\n200"

    when:
      reporter.generate()

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' && it.text.contains('"releaseId": 175706') })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' && it.text.contains('Fortify On Demand Vulnerabilities') })
      1 * steps.archiveArtifacts({ it.artifacts == 'Fortify Scan/FortifyVulnerabilities.*' })
      1 * steps.echo({ it.contains('releaseId=175706') && it.contains('scanId=2274756') })
  }

  def "uses releaseId from env when properties file is missing"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret', FORTIFY_RELEASE_ID: '175706']
      steps.fileExists('Fortify Scan/FortifyScanReport.html') >> false
      steps.fileExists('config/fortify-client.properties') >> false

      def tokenResponse = '{"access_token":"abc"}'
      def scansResponse = '{"items":[{"scanId":2274756,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "${scansResponse}\n200"
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") && m.returnStdout == true }) >> "${vulnsResponse}\n200"

    when:
      reporter.generate()

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
  }

  def "uses releaseId from FortifyScanReport.html when properties file is missing"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('Fortify Scan/FortifyScanReport.html') >> true
      steps.readFile('Fortify Scan/FortifyScanReport.html') >> 'releaseId=175706\n'
      steps.fileExists('config/fortify-client.properties') >> false

      def tokenResponse = '{"access_token":"abc"}'
      def scansResponse = '{"items":[{"scanId":2274756,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "${scansResponse}\n200"
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") && m.returnStdout == true }) >> "${vulnsResponse}\n200"

    when:
      reporter.generate()

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
  }

  def "uses client_credentials grant when username has no tenant"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      def scansResponse = '{"items":[{"scanId":2274756,"scanType":{"name":"Static"},"analysisStatusType":{"name":"Completed"}}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "${scansResponse}\n200"
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") && m.returnStdout == true }) >> "${vulnsResponse}\n200"

    when:
      reporter.generate()

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
      1 * steps.archiveArtifacts({ it.artifacts == 'Fortify Scan/FortifyVulnerabilities.*' })
  }

  def "waits for most recent static scan to complete before fetching vulnerabilities"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      def scansQueuedThenCompleted = '{"items":[{"scanId":1,"scanType":"Static","analysisStatusType":"Queued"},{"scanId":0,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def scansNowCompleted = '{"items":[{"scanId":1,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse

    when:
      reporter.generate(scanPollAttempts: 2, scanPollSleepSeconds: 0)

    then:
      2 * steps.sh({ arg ->
        arg instanceof Map &&
          (((arg.script ?: '') as String).contains("/api/v3/releases/175706/scans")) &&
          (((arg.script ?: '') as String).contains("Authorization: Bearer abc")) &&
          arg.returnStdout == true
      }) >>> ["${scansQueuedThenCompleted}\n200", "${scansNowCompleted}\n200"]

      1 * steps.sh({ arg ->
        arg instanceof Map &&
          (((arg.script ?: '') as String).contains("/api/v3/releases/175706/vulnerabilities")) &&
          (((arg.script ?: '') as String).contains("filters=scanId:1")) &&
          (((arg.script ?: '') as String).contains("Authorization: Bearer abc")) &&
          arg.returnStdout == true
      }) >> "${vulnsResponse}\n200"

      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
  }

  def "falls back to last completed static scan when latest is still queued"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      def scansQueuedAndOlderCompleted = '{"items":[{"scanId":10,"scanType":"Static","analysisStatusType":"Queued"},{"scanId":9,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse

    when:
      reporter.generate(scanPollAttempts: 1, scanPollSleepSeconds: 0)

    then:
      0 * steps.echo({ it.contains('scanId not available') })

      1 * steps.sh({ arg ->
        arg instanceof Map &&
          (((arg.script ?: '') as String).contains("/api/v3/releases/175706/scans")) &&
          (((arg.script ?: '') as String).contains("Authorization: Bearer abc")) &&
          arg.returnStdout == true
      }) >> "${scansQueuedAndOlderCompleted}\n200"

      1 * steps.sh({ arg ->
        arg instanceof Map &&
          (((arg.script ?: '') as String).contains("/api/v3/releases/175706/vulnerabilities")) &&
          (((arg.script ?: '') as String).contains("filters=scanId:9")) &&
          arg.returnStdout == true
      }) >> "${vulnsResponse}\n200"

      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
  }

  def "logs error when scans api returns non-2xx"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "unauthorized\n401"

    when:
      reporter.generate(scanPollAttempts: 1, scanPollSleepSeconds: 0)

    then:
      1 * steps.echo({ it.contains('failed to fetch vulnerability details') })
      0 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
  }

  def "still writes reports when scans api returns no items"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "{}\n200"
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") && m.returnStdout == true }) >> '{"items":[{"id":1,"vulnId":"v1","severityString":"High","category":"XSS","primaryLocationFull":"src/app.js","lineNumber":10}]}\n200'

    when:
      reporter.generate(scanPollAttempts: 1, scanPollSleepSeconds: 0)

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
      1 * steps.archiveArtifacts({ it.artifacts == 'Fortify Scan/FortifyVulnerabilities.*' })
  }

  def "caps vulnerabilities api limit to 50"() {
    given:
      steps.env >> [FORTIFY_USER_NAME: 'client-id', FORTIFY_PASSWORD: 'client-secret']
      steps.fileExists('config/fortify-client.properties') >> true
      steps.readFile('config/fortify-client.properties') >> 'fortify.client.releaseId=175706\n'

      def tokenResponse = '{"access_token":"abc"}'
      def scansResponse = '{"items":[{"scanId":2274756,"scanType":"Static","analysisStatusType":"Completed"}]}'
      def vulnsResponse = '{"items":[]}'

      steps.sh("mkdir -p 'Fortify Scan'") >> null
      steps.sh({ Map m -> (m.script as String).contains("grant_type=client_credentials") && m.returnStdout == true }) >> tokenResponse
      steps.sh({ Map m -> (m.script as String).contains("/api/v3/releases/175706/scans") && m.returnStdout == true }) >> "${scansResponse}\n200"
      steps.sh({
        Map m ->
          (m.script as String).contains("/api/v3/releases/175706/vulnerabilities") &&
            (m.script as String).contains("limit=50") &&
            m.returnStdout == true
      }) >> "${vulnsResponse}\n200"

    when:
      reporter.generate(pageLimit: 200)

    then:
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.json' })
      1 * steps.writeFile({ it.file == 'Fortify Scan/FortifyVulnerabilities.html' })
  }
}
